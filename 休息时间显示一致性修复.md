# 休息时间显示一致性修复

## 📋 问题描述

用户报告了休息时间显示和实际休息时间不一致的问题：

1. **倒计时按钮**显示 18 分钟（包含累积的未完成休息时间）
2. **遮罩层提示消息**只显示 6 分钟（基础休息时间）
3. **实际休息时间**未达到 18 分钟就结束了

## 🔍 根本原因分析

### 问题根源

**不一致的累积时间处理逻辑**：

1. **短休息启动**（`startShortBreak()`）：
   - ❌ 只设置 `remainingTime = breakTime`
   - ❌ 没有加上累积的未完成时间
   - ❌ 累积时间被保留但未使用

2. **长休息启动**（`startLongBreak()`）：
   - ✅ 正确加上累积时间
   - ✅ 重置 `accumulatedRestTime = 0`
   - ❌ 但重置后 `getCurrentBreakInfo()` 无法获取正确的总时长

3. **获取休息信息**（`getCurrentBreakInfo()`）：
   - ❌ 长休息尝试读取已被重置的 `accumulatedRestTime`
   - ❌ 短休息完全忽略累积时间
   - ❌ 返回的是基础时间，而非实际总时长

### 时间流程示例

**场景**：用户在短休息期间取消 2 次，累积 12 分钟，下次应为长休息

```
取消第1次短休息 → accumulatedRestTime += 6分钟
取消第2次短休息 → accumulatedRestTime += 6分钟
累积时间: 12分钟

下次是长休息:
startLongBreak():
  totalLongBreakTime = 15分钟 + 12分钟 = 27分钟
  remainingTime = 27分钟  ✅ 正确
  accumulatedRestTime = 0  ⚠️ 清零了！

getCurrentBreakInfo():
  totalLongBreakTime = 15分钟 + accumulatedRestTime(0)
  返回: 15分钟  ❌ 错误！应该是27分钟

倒计时按钮:
  getRemainingTime() → 27分钟  ✅ 正确

遮罩层消息:
  getCurrentBreakInfo() → 15分钟  ❌ 错误！
```

## ✅ 解决方案

### 核心思路

**引入 `currentRestDuration` 变量**保存当前休息周期的总时长，避免依赖已被重置的 `accumulatedRestTime`。

### 代码修改

#### 1. 添加新属性

```swift
private var currentRestDuration: TimeInterval = 0 // 当前休息周期的总时长（包括累积时间）
```

#### 2. 修改 `startShortBreak()`

**修改前**：
```swift
internal func startShortBreak() {
    isLongBreak = false
    autoRestartStateMachine.setTimerType(.shortBreak)
    remainingTime = breakTime  // ❌ 没有加累积时间
    print("☕ 开始短休息，时长 \(Int(breakTime/60)) 分钟")
    
    statisticsManager.recordShortBreakStarted(duration: breakTime)
    processAutoRestartEvent(.restStarted)
    start()
}
```

**修改后**：
```swift
internal func startShortBreak() {
    isLongBreak = false
    autoRestartStateMachine.setTimerType(.shortBreak)
    
    // 计算短休息时间（包括累积的时间）
    var totalShortBreakTime = breakTime
    if accumulateRestTime && accumulatedRestTime > 0 {
        totalShortBreakTime += accumulatedRestTime
        print("🎯 累加短休息中断时间 \(Int(accumulatedRestTime/60)) 分钟到短休息")
        accumulatedRestTime = 0 // 重置累积时间
    }
    
    remainingTime = totalShortBreakTime  // ✅ 包含累积时间
    currentRestDuration = totalShortBreakTime  // ✅ 保存总时长
    print("☕ 开始短休息，时长 \(Int(totalShortBreakTime/60)) 分钟")
    
    statisticsManager.recordShortBreakStarted(duration: totalShortBreakTime)
    processAutoRestartEvent(.restStarted)
    start()
}
```

#### 3. 修改 `startLongBreak()`

**修改前**：
```swift
private func startLongBreak() {
    isLongBreak = true
    autoRestartStateMachine.setTimerType(.longBreak)
    
    var totalLongBreakTime = longBreakTime
    if accumulateRestTime && accumulatedRestTime > 0 {
        totalLongBreakTime += accumulatedRestTime
        accumulatedRestTime = 0
    }
    
    remainingTime = totalLongBreakTime
    // ❌ 没有保存 totalLongBreakTime 供后续使用
    // ...
}
```

**修改后**：
```swift
private func startLongBreak() {
    isLongBreak = true
    autoRestartStateMachine.setTimerType(.longBreak)
    
    var totalLongBreakTime = longBreakTime
    if accumulateRestTime && accumulatedRestTime > 0 {
        totalLongBreakTime += accumulatedRestTime
        print("🎯 累加短休息中断时间 \(Int(accumulatedRestTime/60)) 分钟到长休息")
        accumulatedRestTime = 0
    }
    
    remainingTime = totalLongBreakTime
    currentRestDuration = totalLongBreakTime  // ✅ 保存总时长
    print("🌟 开始长休息，时长 \(Int(totalLongBreakTime/60)) 分钟")
    // ...
}
```

#### 4. 修改 `getCurrentBreakInfo()`

**修改前**：
```swift
func getCurrentBreakInfo() -> (isLongBreak: Bool, breakMinutes: Int) {
    if isLongBreak {
        var totalLongBreakTime = longBreakTime
        if accumulateRestTime && accumulatedRestTime > 0 {
            totalLongBreakTime += accumulatedRestTime  // ❌ accumulatedRestTime 已被重置为0
        }
        return (true, Int(totalLongBreakTime / 60))
    } else {
        return (false, Int(breakTime / 60))  // ❌ 没有包含累积时间
    }
}
```

**修改后**：
```swift
func getCurrentBreakInfo() -> (isLongBreak: Bool, breakMinutes: Int) {
    // 如果当前正在休息期间，返回当前休息周期的总时长
    if isInRestPeriod && currentRestDuration > 0 {
        return (isLongBreak, Int(currentRestDuration / 60))  // ✅ 使用保存的总时长
    }
    
    // 如果不在休息期间，返回预计的休息时间
    if isLongBreak {
        var totalLongBreakTime = longBreakTime
        if accumulateRestTime && accumulatedRestTime > 0 {
            totalLongBreakTime += accumulatedRestTime
        }
        return (true, Int(totalLongBreakTime / 60))
    } else {
        var totalShortBreakTime = breakTime
        if accumulateRestTime && accumulatedRestTime > 0 {
            totalShortBreakTime += accumulatedRestTime  // ✅ 包含累积时间
        }
        return (false, Int(totalShortBreakTime / 60))
    }
}
```

#### 5. 重置 `currentRestDuration`

在休息结束时重置：

```swift
// cancelBreak()
stop()
isLongBreak = false
currentRestDuration = 0  // ✅ 重置
// ...

// finishBreak()
stop()
isLongBreak = false
currentRestDuration = 0  // ✅ 重置
// ...
```

## 🎯 修复效果

### 修复后的时间流程

```
取消第1次短休息 → accumulatedRestTime += 6分钟
取消第2次短休息 → accumulatedRestTime += 6分钟
累积时间: 12分钟

下次是长休息:
startLongBreak():
  totalLongBreakTime = 15分钟 + 12分钟 = 27分钟
  remainingTime = 27分钟  ✅
  currentRestDuration = 27分钟  ✅ 新增：保存总时长
  accumulatedRestTime = 0

getCurrentBreakInfo():
  if isInRestPeriod && currentRestDuration > 0:
    返回: currentRestDuration = 27分钟  ✅ 正确！

倒计时按钮:
  getRemainingTime() → 27分钟  ✅

遮罩层消息:
  getCurrentBreakInfo() → 27分钟  ✅ 修复！
```

### 一致性验证

| 显示位置 | 修复前 | 修复后 |
|---------|-------|-------|
| **倒计时按钮** | 18分钟 ✅ | 18分钟 ✅ |
| **遮罩层消息** | 6分钟 ❌ | 18分钟 ✅ |
| **实际休息时间** | 提前结束 ❌ | 18分钟 ✅ |

## ✅ 测试验证

### 单元测试结果

所有 `BreakMessageTests` 测试通过：

```
✅ testGetCurrentBreakInfo_ShortBreak() - 短休息信息获取
✅ testGetCurrentBreakInfo_LongBreak() - 长休息信息获取
✅ testGetCurrentBreakInfo_DifferentSettings() - 不同设置测试
✅ testGetCurrentBreakInfo_WithAccumulatedTime() - 累积时间功能测试
✅ testGetCurrentBreakInfo_ZeroMinutes() - 边界情况测试
✅ testGetCurrentBreakInfo_LargeValues() - 大数值测试
```

### 手动测试场景

**场景1：短休息（无累积）**
- 设置：短休息 5 分钟
- 预期：倒计时按钮、遮罩层消息、实际休息均为 5 分钟 ✅

**场景2：短休息（有累积）**
- 前提：累积 6 分钟未完成的休息
- 设置：短休息 5 分钟
- 预期：倒计时按钮、遮罩层消息、实际休息均为 11 分钟 ✅

**场景3：长休息（有累积）**
- 前提：累积 12 分钟未完成的休息
- 设置：长休息 15 分钟
- 预期：倒计时按钮、遮罩层消息、实际休息均为 27 分钟 ✅

## 📝 设计说明

### 为什么使用 `currentRestDuration`

**方案对比**：

| 方案 | 优点 | 缺点 |
|------|------|------|
| **方案A：不清零 `accumulatedRestTime`** | 简单 | 违反业务逻辑，累积时间不应保留 |
| **方案B：传递参数** | 不增加状态 | 需要修改多处调用点，耦合度高 |
| **方案C：新增 `currentRestDuration`** ✅ | 状态清晰，易维护 | 增加一个属性 |

选择方案C的原因：
1. **状态独立**：`currentRestDuration` 只在休息期间有效，不影响其他逻辑
2. **语义清晰**：明确表示"当前休息周期的总时长"
3. **易于维护**：休息开始时设置，休息结束时重置，生命周期明确
4. **向后兼容**：不影响现有调用代码

### 时间管理层次

```
累积时间（跨周期）: accumulatedRestTime
      ↓ 累加到
当前休息总时长: currentRestDuration  ← 用于显示
      ↓ 倒计时
剩余时间（实时）: remainingTime      ← 用于倒计时
```

## 🔧 相关文件

- `PomodoroScreen/PomodoroTimer.swift`
  - `startShortBreak()` - 短休息启动逻辑
  - `startLongBreak()` - 长休息启动逻辑
  - `getCurrentBreakInfo()` - 获取休息时间信息
  - `cancelBreak()` - 取消休息
  - `finishBreak()` - 完成休息

- `PomodoroScreen/UI/Window/OverlayWindow.swift`
  - `setupMessageLabel()` - 遮罩层消息显示
  - `getCountdownString()` - 倒计时按钮文字

## 📊 影响范围

### 直接影响
- ✅ 遮罩层消息显示正确的休息时长
- ✅ 倒计时按钮显示一致的时间
- ✅ 实际休息时间与显示时间一致

### 间接影响
- ✅ 统计数据更准确（使用实际总时长）
- ✅ 用户体验更好（信息一致，不会困惑）
- ✅ 代码逻辑更清晰（状态管理分离）

## 🎉 总结

通过引入 `currentRestDuration` 变量，成功解决了休息时间显示不一致的问题：

1. **短休息**现在正确包含累积时间
2. **长休息**的总时长在清零累积时间后仍能正确获取
3. **所有显示位置**（倒计时按钮、遮罩层消息、实际休息）现在完全一致
4. **单元测试**全部通过，确保修复稳定可靠

---

**作者**: AI Assistant  
**修复时间**: 2026-01-09  
**相关问题**: 休息时间显示与实际不一致
