# 测试用例：系统睡眠时不记录熬夜活动

## 功能说明

当Mac笔记本盖上盖子进入睡眠状态时，应停止记录熬夜活动。从睡眠中唤醒后，恢复记录。

**新增功能**（2026-01-03）：
- ✅ 系统唤醒后自动刷新状态栏图标
- ✅ 如果唤醒时已过熬夜时段（如第二天早上6点后），状态栏会自动从"请勿熬夜"🌙切换回正常时钟

## 实现机制

### 1. 睡眠状态监听

在 `AutoRestartStateMachine` 中添加了系统睡眠/唤醒通知监听：

```swift
// 睡眠状态标记
private var isSystemSleeping: Bool = false

// 在 init 中注册通知
NSWorkspace.shared.notificationCenter.addObserver(
    self,
    selector: #selector(systemWillSleep),
    name: NSWorkspace.willSleepNotification,
    object: nil
)

NSWorkspace.shared.notificationCenter.addObserver(
    self,
    selector: #selector(systemDidWake),
    name: NSWorkspace.didWakeNotification,
    object: nil
)
```

### 2. 睡眠/唤醒处理

```swift
@objc private func systemWillSleep() {
    print("🛌 系统即将睡眠，停止记录熬夜活动")
    isSystemSleeping = true
}

@objc private func systemDidWake() {
    print("🛌 系统已唤醒，恢复记录熬夜活动")
    isSystemSleeping = false
    lastStayUpLoggedSlot = nil // 重置时间槽
    
    // 记录唤醒前的熬夜状态
    let wasStayUpBeforeSleep = isStayUpTime
    
    // 立即检查熬夜状态
    updateStayUpStatus()
    
    // 如果唤醒后熬夜状态发生了变化，触发回调刷新状态栏
    if wasStayUpBeforeSleep && !isStayUpTime {
        print("🛌 唤醒后熬夜时段已结束，强制刷新状态栏")
        onStayUpTimeChanged?(false)
    }
    
    // 无论如何都触发系统唤醒回调，确保UI刷新
    print("🛌 触发系统唤醒UI刷新回调")
    onSystemWakeup?()
}
```

### 3. UI刷新回调

在 `PomodoroTimer.swift` 中注册回调：

```swift
// 设置系统唤醒回调，用于刷新状态栏
autoRestartStateMachine.onSystemWakeup = { [weak self] in
    guard let self = self else { return }
    AppLogger.shared.logStateMachine("SystemWakeup -> 强制刷新状态栏", tag: "SLEEP")
    // 强制触发一次计时器更新，刷新状态栏图标
    self.updateTimeDisplay()
}
```

### 4. 记录逻辑保护

在 `maybeLogStayUpActivity()` 中添加睡眠状态检查：

```swift
private func maybeLogStayUpActivity() {
    // 如果系统处于睡眠状态，不记录熬夜活动
    guard !isSystemSleeping else {
        print("🛌 系统处于睡眠状态，跳过记录熬夜活动")
        return
    }
    
    // ... 正常的记录逻辑 ...
}
```

## 手动测试步骤

### 测试场景1：睡眠期间不记录

**前置条件**：
- 当前时间处于熬夜时段（例如 23:30 之后）
- 应用正在运行

**测试步骤**：
1. 启动 PomodoroScreen 应用
2. 等待进入熬夜时段（或修改系统时间到 23:30）
3. 观察控制台，确认看到 "🟡 记录熬夜活动" 日志
4. 合上 MacBook 盖子，让系统进入睡眠
5. 等待至少30分钟（跨越一个半小时时间槽）
6. 打开盖子，唤醒系统
7. 查看数据库或报告

**预期结果**：
- 睡眠前应看到日志：`🛌 系统即将睡眠，停止记录熬夜活动`
- 唤醒后应看到日志：`🛌 系统已唤醒，恢复记录熬夜活动`
- 睡眠期间的时间槽不应该被记录为熬夜活动
- 唤醒后的新时间槽应该正常记录

### 测试场景2：唤醒后恢复记录

**前置条件**：
- 同上

**测试步骤**：
1. 从睡眠状态唤醒 Mac
2. 观察控制台输出
3. 等待进入下一个半小时时间槽（如 00:00 或 00:30）
4. 检查是否记录了新的熬夜活动

**预期结果**：
- 唤醒后立即看到：`🛌 系统已唤醒，恢复记录熬夜活动`
- 下一个半小时槽到达时看到：`🟡 记录熬夜活动 - 时间槽: XX:XX`
- 数据库中应有新的 `stayUpLateActivity` 记录

### 测试场景3：多次睡眠/唤醒循环

**测试步骤**：
1. 在熬夜时段内
2. 执行多次睡眠/唤醒操作（至少3次）
3. 每次唤醒后等待1-2分钟
4. 最终查看数据库记录

**预期结果**：
- 每次睡眠都应该停止记录
- 每次唤醒都应该恢复记录
- 不应该出现睡眠期间的虚假记录
- 日志中应该有成对的睡眠/唤醒消息

### 测试场景4：第二天早上唤醒后状态栏刷新 ⭐️NEW

**前置条件**：
- 当前时间处于熬夜时段（例如 23:30）
- 应用正在运行，状态栏显示 "🌙 请勿熬夜"

**测试步骤**：
1. 在熬夜时段（如晚上23:30）确认状态栏显示 "🌙 请勿熬夜"
2. 合上 MacBook 盖子进入睡眠
3. 第二天早上（6:00之后）打开盖子唤醒系统
4. 观察状态栏图标和文字

**预期结果**：
- ✅ 状态栏应该**自动刷新**，不再显示 "🌙 请勿熬夜"
- ✅ 状态栏应该显示正常的时钟图标和倒计时时间
- ✅ 控制台日志显示：
  ```
  🛌 系统已唤醒，恢复记录熬夜活动
  🛌 唤醒后熬夜时段已结束，强制刷新状态栏
  🛌 触发系统唤醒UI刷新回调
  [AppLogger] [SLEEP] SystemWakeup -> 强制刷新状态栏
  ```
- ❌ **不应该**需要手动点击或重启应用才能看到正确的图标

**测试重要性**：
- 这是本次修复的核心场景
- 验证系统唤醒后UI能够自动同步状态变化

## 数据库验证

### 查询熬夜活动记录

```bash
cd PomodoroScreen/Debug
sqlite3 statistics-debug.db "
SELECT 
    datetime(timestamp, 'unixepoch', 'localtime') as time,
    event_type,
    metadata
FROM statistics_events
WHERE event_type = 'stay_up_late_activity'
ORDER BY timestamp DESC
LIMIT 10;
"
```

### 验证时间槽间隔

检查相邻记录之间的时间间隔：
- 正常情况下应该是30分钟
- 如果跨越了睡眠期间，间隔会大于30分钟（这是正常的）

## 验收标准

✅ **通过条件**：
1. 系统进入睡眠时，控制台输出 "系统即将睡眠" 日志
2. 睡眠期间不产生任何 `stayUpLateActivity` 记录
3. 系统唤醒时，控制台输出 "系统已唤醒" 日志
4. 唤醒后能够正常记录新的熬夜活动
5. 热力图中不显示睡眠期间的黄色标记

❌ **失败条件**：
1. 睡眠期间仍然记录了熬夜活动
2. 唤醒后无法恢复记录
3. 睡眠/唤醒通知没有被正确处理
4. 内存泄漏（通知监听器未正确移除）

## 注意事项

### 代码更改说明

**修改的文件**：
- `AutoRestartStateMachine.swift`
  - 添加 `import AppKit`
  - 添加 `isSystemSleeping` 状态标记
  - 添加 `setupSleepNotifications()` 和 `removeSleepNotifications()`
  - 添加 `@objc systemWillSleep()` 和 `@objc systemDidWake()`
  - 在 `maybeLogStayUpActivity()` 中添加睡眠状态检查

**设计决策**：
- 使用 `NSWorkspace` 通知而非 `IOPMAssertionCreateWithName`，因为前者更简单可靠
- 在 `deinit` 中移除通知监听器，防止内存泄漏
- 唤醒后重置 `lastStayUpLoggedSlot`，确保能立即记录新的时间槽
- 睡眠状态检查放在记录逻辑的最前面，确保不会遗漏

### 已知限制

1. **手动测试为主**：由于涉及系统级睡眠事件，自动化单元测试较难实现
2. **时间同步**：如果睡眠时间很长（数小时），唤醒后需要等到下一个半小时槽才会记录
3. **电源管理**：某些电源管理设置可能影响睡眠通知的发送

## 调试建议

如果遇到问题，可以：

1. **检查日志输出**：
   ```bash
   log stream --predicate 'subsystem contains "com.yourapp"' --level debug
   ```

2. **验证通知注册**：
   在 `setupSleepNotifications()` 中添加断点

3. **模拟睡眠事件**（用于调试）：
   ```swift
   // 手动触发睡眠通知（仅用于测试）
   NotificationCenter.default.post(
       name: NSWorkspace.willSleepNotification,
       object: nil
   )
   ```

4. **检查数据库时间戳**：
   确保记录的时间戳与实际清醒时间对应

## 相关文档

- `专注模式功能说明.md` - 类似的系统事件处理
- `自动检测投屏功能说明.md` - 系统状态监听机制
- `AutoRestartStateMachine.swift` - 状态机实现细节

